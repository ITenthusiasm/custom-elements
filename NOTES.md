# Notes

- [`Element.getAttributeNames()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames) -- when used in conjunction with [`Element.getAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute) -- is allegedly more performant than [`Element.attributes`](https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes).
  - MDN's docs/notes on [live HTML collections](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection) might prove insightful here.
- Based on MDN's notes about [`DocumentOrShadowRoot.activeElement`](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement) and [`Document.hasFocus()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/hasFocus), it seems like `document.activeElement` is only guaranteed to be `:focus`ed _if_ said element is in a `Document` satisfying `Document.hasFocus() === true`. This is worth remembering. That said, in some cases (as in some of our `combobox` logic), it is sufficient to just check `document.activeElement` to achieve the desired behavior. What you need to do depends on your use case.

## `ComboboxField` + `listbox`

- **Screen Readers and `[role="option"][inert]`**: It seems that if the only child in a `listbox` is a `[role="option"][inert]` HTMLElement, then Screen Readers (or at least VoiceOver) will view the `listbox` as empty. This is a big deal because it's important to have _some_ kind of indicator that no `option`s match the user's current filter. Showing a blank screen (i.e., showing no menu when no `option`s match the filter) could work, but that may not be as clear. Between `Mantine`, `Shadcn UI`, `Reach UI`, `React Select`, and `Vue Select`, Mantine is the only Component Library that doesn't have a "No Options" display. If we can meet accessibility requirements **_and_** make things clearer for visual users, we should definitely do **_both_**.
- You should prefer private `static` methods for event handlers whenever possible. However, if you **_need_** access to `this`, then just use a private arrow function. Certainly, if you can find a way to _avoid_ using `this` so that you can keep a method as `static`, then do so. However, you should do this reasonably. For example, it is _unreasonable_ to expose a copy of a private field (`get matchingOptions() { return this.#matchingOptions.slice() }`) strictly for the sake of being able to use a `static` method for an event handler. Not only does this waste memory at runtime, but it runs the risk of introducing confusion and unforeseen bugs. Keep things simple and just use an arrow function if you need to; it shouldn't harm your end users.
  - As a side note, for this very reason, **_you should avoid using `this` as much as possible (within reason)_**. It's theoretically possible that in the future, a refactor would make itself known which would enable you convert your instance arrow function back to a `static` method. Those opportunities will become more obvious if you, for example, reach for a `combobox` via `event.target` instead of through `this`.
- Currently, our `combobox` component displays a "No Options" message (which is an `inert`, fake `option`) if the user's filter doesn't match any of the component's options. (This is only in `filter` mode, obviously.) This message is modifiable, but some people may not want to display a message at all. In that case, they can simply use CSS to hide the `listbox` if it doesn't contain any `option`s which aren't [`data-filtered-out`]; there are no code changes that need to be made on our side. But this is at least worth documenting when we write the overall documentation for this component.

## DOM / JavaScript

- Apparently, the `focus` event triggers after the `mousedown` event but before the `mouseup` event, which triggers immediately before the `click` event. We were able to use this knowledge to differentiate between `:focus`ing that was initiated by clicking vs. tabbing in our code.
- If a `Range` points to content inside a [`Text`](https://developer.mozilla.org/en-US/docs/Web/API/Text) Node (which is itself [`CharacterData`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData), which seems to have many helpful methods), then using [`CharacterData.insertData()`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/insertData) **_will not_** reset the `Range` offsets to the beginning of the Node (unlike changing the [`Node.nodeValue`](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue) directly with something like `textNode.nodeValue = MY_STRING`).
- [According to the Spec](https://dom.spec.whatwg.org/#dom-node-textcontent), an element's child nodes will be _completely_ removed when the [`Element.textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) setter is called. If the setter is called with an empty string (or anything that is _mapped_ to an empty string), then the element will be left empty. (This seems similar to how `Element.innerHTML` behaves when given an empty string.) If the setter is called with a regular string, then a new `Text` node is created and inserted as the the element's only child.
  - We'll need to be mindful of this in the codebase. If we expect a component to _always_ have a text node (as is the assumption for the `<combobox-field>`), then we'll need to avoid using `Element.textContent = ""`. Instead, we'll need to leverage `Text.nodeValue = ""` or another similarly-safe approach (like [`CharacterData.data = ""`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/data)).
  - This piece of information is also important when it comes to modifying `Range`s, as deleting/replacing the reference to an element's original `Text` node can lead to unexpected/broken behavior when trying to work with `Range`s that point to the element's contents.
- For some odd reason, in `Chrome` and `Firefox`, the UserAgent (UA) would try to focus the `listbox` in the `<select-enhancer>` whenever `Tab` was pressed if the `combobox` was expanded. This happened both while `Tab`bing forwards and backwards. The behavior is most easily replicated if you force the `combobox` to be expanded with `setAttribute` and then try moving focus with `Tab`. (Safari did not exhibit this awful and confusing behavior.) This caused unexpected bugs in the code, so now we have to place a `[tabindex="-1"]` attribute on the `listbox` element.
- [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/disabled) form controls that are [`contenteditable`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/contenteditable) behave differently across different browsers. Consider `<button disabled contenteditable="true">Content</button>` in each of the 3 Major Browsers:
  - **Chrome** (137): Prevents focusing via Keyboard Navigation (`Tab`bing), Clicking, and `HTMLElement.focus()`. This is the ideal behavior.
  - **Safari** (18.5): Prevents focusing via Keyboard Navigation (`Tab`bing) and `HTMLElement.focus()`. However, if the element is clicked, it receives a cursor and can still be modified.
  - **Firefox** (140): Does not prevent **_ANY_** of the 3 aforementioned means of focusing an element. To Firefox, if the element is `contenteditable`, it's focusable.
  - Due to these discrepancies, if you want a `[contenteditable]` form control _not_ to be interactive when `disabled`, then you'll have to toggle `[contenteditable]` between `"false"` and `"true"` yourself.
- Apparently, when a `:focused` element is dynamically given the attribute `[contenteditable="true"]`, a cursor **_is not_** put inside the element. (This is at least true for Google Chrome `138` on MacOS `15.5`.) Although the practicality of such a scenario is probably small, this is still something worth noting. This means that users have no way of knowing that an element with which they're interacting has become editable without leaving the element and re-focusing it. The way that our `<combobox-field>` gets around this issue is by highlighting all of its own text content if it becomes editable while being in focus.
- Apparently, elements that are `[contenteditable]` have _all_ of their child DOM Nodes removed when 1&rpar; There is no more text within the element and 2&rpar; `Backspace` (_not_ `Delete`) is pressed ([Svelte REPL Example](https://svelte.dev/playground/332549859b824757a64962c70b18bce3?version=5.38.5)). What's even more interesting is that this behavior has some minor differences across browsers:
  - **Chrome** (138) + **Firefox** (140): If `Backspace` is pressed in a `[contenteditable]` element containing a single _empty_ `Text` Node, the Node will be preserved in the DOM; it will not be deleted.
  - **Safari** (18.5): If `Backspace` is pressed in a `[contenteditable]` element containing a single _empty_ `Text` Node, the Node will be **removed** from the DOM.
  - These manual checks were run on MacOS 15.5. Safari's treatment of `Text` Nodes _might_ be a bug, but it also might be behavior that isn't strictly defined or enforced by the WHATWG/W3C. Thus, if you want to counteract this Safari behavior, your best bet is to use a `MutationObserver` that reinserts the desired DOM Node(s). As an example, the `ComboboxField` has to do this because it assumes that it _always_ has a _consistent_, _singular_ `Text` Node for displaying important information to Users (e.g, the User's filter, the `combobox`'s current value, etc.). Having a `MutationObserver` like this also protects against undesirable manipulation of the `<combobox-field>`'s child nodes.
    - TODO: Although a `MutationObserver` is a suitable solution, you should consider opening a Safari bug in case this really is a bug on their part. (That said, it might be a good idea to maintain the current `MutationObserver`/logic even if Safari changes the Browser Behavior. This is because doing so would protect against undesirable child node manipulation from outside sources, such as rogue developers or misused JS Frameworks.)
- From our brief experience, it seems that the properties of [`ElementInternals.validity`](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/validity) cannot be spread into a new object, nor can they be [`structuredClone`d](https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone). Additionally, [`ElementInternals.setValidity()`](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/setValidity) will always default any `ValidityState` properties that you _don't_ pass to the function to `false`. This makes it **_incredibly_** difficult to transition between different error states, because you have to track previously-established error messages (when transitioning, for example, from 2 errors to 1), and you have to write unnecessarily verbose code to maintain the current error state when you only want to, say, update an error message. These matters get even worse when you want one kind of error message to unconditionally take precedence over another one (e.g., `customError` > `valueMissing`). These issues should probably be reported to the WHATWG on GitHub.
- Related to our previous note, it seems that some object properties are [_enumerable_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Enumerability_and_ownership_of_properties) whereas others are not. Just like `ValidityState`'s object properties are non-enumerable, most `Event` properties are also non-enumerable (except for `isTrusted`). So copying details like those belonging to an `InputEvent` will be more verbose **_if_** you are trying to copy only _part_ of the object. If you want to copy the entire object, then `Element.dispatchEvent(new event.constructor(event.type, event))` will do just fine.
- Apparently, in `Google Chrome 138` on `MacOS 15.5`, Chrome will remove focus from an HTMLElement if it is moved somewhere else in the DOM. (`Firefox 140` and Safari `18.5` do not exhibit this behavior.) This is important to remember as we write our tests. Since this is specifically related to browsers and how they choose to trigger `FocusEvent`s, this is something that developers will have to take responsibility for; this is not caused by a flaw in our component.
- The [order in which Web Components are registered matters](https://stackoverflow.com/a/67440254/17777687). Particularly, the order matters when an HTML Page is loaded with the Web Components in the markup. In this scenario, the `connectedCallback()`s of these Web Components will run in the order in which the Custom Elements were defined. However, if the Web Components _were not_ connected to the DOM on page load and were instead added after the browser's initial HTML Parsing, then the `connectedCallback()`s will be run in the natural order which one would expect (i.e., Parent, then all Children, in order).
- Oddly enough, there are still more browser discrepancies. In `Google Chrome 140` on `MacOS 15.6.1` **_and_** `Safari 18.6` on `MacOS 15.6.1`, no `click` event will be dispatched if the following actions occur in succession: 1&rpar; pressing the mouse down in a text-editable element (such as an `<input>` or `[contenteditable="true"]` element), 2&rpar; moving the mouse outside the text-editable element, 3&rpar; releasing the mouse. Indeed, this is the behavior that I think people would typically expect. However, `Firefox 142` on `MacOS 15.6.1` **_does not_** exhibit this behavior!!! Instead, the `click` event is dispatched on the element on which the mouse was originally pressed down. In fact, in Firefox, the `mouseleave` event doesn't fire until **_after_** the `click` event has fired. This might be an insanely annoying and unintuitive Browser implementation, or it's a Browser bug.
- Apparently, elements created inside `<template>`s are created in an entirely different "Document context" than the Window's. Because of this, any Custom Elements registered with `window.customElements.define()` won't be recognized/acknowledged by elements created within the `<template>` (e.g., with `template.innerHTML`). This can be resolved by cloning the `template`'s nodes into the Window's Document (e.g., with `document.importNode(template.content, true)`), then attaching the _cloned_ nodes to the Window's DOM. We had to learn this the hard way in one of our Playwright tests. Below are some helpful resources on this topic:
  - https://stackoverflow.com/questions/55791168/initialisation-of-custom-elements-inside-document-fragment/67252742#67252742
  - https://dev.to/mayankav/template-vs-div-3b32 (Especially helps with understanding why `Vue` uses `<template>`)
  - Also read up on [`Document.adoptNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptNode) and [`Document.importNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/importNode), which are distinct from [`Node.cloneNode()`](https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode).

## TypeScript

- TypeScript seems to have some [very firm rules](https://devblogs.microsoft.com/typescript/announcing-typescript-5-8/#preserved-computed-property-names-in-declaration-files) about declaring dynamic property names in `class`es. Basically, if you're going to go that route, then you'll need a static string or a unique `Symbol` (which can be "dynamic" &mdash; i.e., calculated at runtime). The latter is especially helpful for avoiding TypeScript errors with Index Signatures. (For example, you don't want your `class` to become `Record<string, number>`. `Symbol`s seem pretty much guaranteed to help you avoid this, though _constant_, _static_ strings also seem to be usable in later versions of TypeScript as well.)
  - We explored dynamic property names in the `ComboboxField` to see if we could have "private" instance data that could still be accessed from `static` event handler methods. Due to the index signature issue mentioned previously, `Symbol`s seemed to be the best approach here. Unfortunately, those who read our source code could potentially still [leverage the `Symbol` registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for) to access data that they should not touch. To get around this, a secure, random runtime string can be _generated_ and passed to `Symbol` when the library is first loaded. People could technically still get around this by brute forcing the `Symbol` registry. But for anyone building a true, meaningful application, this would _not_ be worth their time. (And it would certainly hurt performance for Users.) So this approach virtually holds the same security as private fields.
    - There are caveates with this `Symbol` approach, however. The largest concern is that &mdash; at least as of today (2025-08-30) &mdash; JSDocs don't work as cleanly on these kinds of dynamically-declared properties. Additionally, there is a (minor) cost for generating random strings (say, UUIDs) at runtime; and it's likely that more memory would have to be allocated than what is needed for regular, private fields. (That said, if you get to preserve your use of `static` methods with this approach, then the memory allocation might be superior in the end.) As a side note, remember that even if the two random strings you generate are exactly the same, you won't run into any issues there since `Symbol()` always produces a unique value. So name clashing within your `class` won't be a practical concern.

## `Ranges`, `Selection`, and Reimplementing the `input` Event

- Useful links/docs:
  - https://javascript.info/selection-range
  - https://developer.mozilla.org/en-US/docs/Web/API/Range
  - https://developer.mozilla.org/en-US/docs/Web/API/Selection
- Firefox is the only Browser that supports multi-selection. We could skip supporting it, but we'll choose to support it to avoid breaking user expectations. Note that when Firefox encounters a multi-select for an `<input>` element, it will place the selection at the very end of the _last_ selection range when text is inserted into the form control. (You should TEST that you're satisfying this behavior.)
- Unlike `Chrome` and `Firefox`, in `Safari` you cannot use [`Selection.addRange()`](https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange) to set the `Document`'s current selection to something WITHIN a `Shadow DOM`. However, you CAN use [`Selection.setBaseAndExtent()`](https://developer.mozilla.org/en-US/docs/Web/API/Selection/setBaseAndExtent) for this. Note that Chrome/Firefox support `Selection.addRange()` if the `Range` has "legal" access to content in a `Shadow DOM`. However, since we're trying to create something with cross-browser support, this is irrelevant. Some helpful resources:
  - Some hiccups people have run into when trying to get Selections in the Shadow DOM: https://stackoverflow.com/questions/62054839/shadowroot-getselection/70523247#70523247
  - What seems to be some discussion on the new expectations/hopes for how `Selection` will behave in the Shadow DOM: https://github.com/mfreed7/shadow-dom-selection?tab=readme-ov-file#changes-to-existing-selection-apis. (This may not technically be the official spec, but it seems to be the direction in which things are moving so far.)
- Apparently, all (non-static) `Range`s previously associated with a `Text` Node get emptied once the referenced node's `nodeValue` is re-set with `set Node.nodeValue()`. (The `Range`s probably don't know what to point to anymore since the underlying value of the `Node` has technically changed.) This makes it imperative that you know when to leverage the a `StaticRange` and when to work directly with a regular, dynamic `Range` (or a value that it cached before being modified).
  - Alternatively, you can just leverage the `CharacterData` methods, like `insertData()` and `deleteData()`. These methods will _preserve_ the `Range` information of the `Text` node that you're modifying (as much as possible) -- even if some of the `Range`'s contents are deleted by `deleteData()`. Why worry about what `set Node.nodeValue()` will do and how you should cache your `Range` data when you can just use the `CharacterData` methods to help you avoid worrying about such things?
- By default, browsers will collapse multiple occurrences of whitespace between character strings. So if you have a `<div contenteditable="true">` and you execute `div.textContent = "Hello" + " ".repeat(5) + "World"`, then the browser will display what _looks_ like `"Hello World"` even though `get div.textContent()` will return a string with the appropriate number of spaces. To force the browser to display _all_ whitespace instead of collapsing it, you need to use the [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space) CSS property. (You can also try [`white-space-collapse`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse), but broad and stable support for the `preserve-spaces` value is missing.)
  - If you're wondering how users can insert multiple spaces into `[contenteditable]` elements, it's because the browser inserts HTML into the `[contenteditable]` element instead of pure white space. In other words, the browser will insert something like `Hello&nbsp; &nbsp; &nbsp;World` instead of using empty strings only. However, this behavior is not always desirable. We concluded that this behavior wasn't viable for our `ComboboxField` since we're accepting and manipulating Plaintext only instead of HTML. (That is, we use `"text/plain"` in `DataTransfer.getData()` instead of `"text/html"`.) So we intentionally used pure white spaces when re-implementing the `input` event. (Indeed, I think we were _forced_ to.) Consequently, we recommend users update the `white-space` CSS property of the `<combobox-field>` as needed.
- The `[contenteditable="plaintextonly"]` attribute setting seems to behave inconsistently between Browsers. For this reason, it's best to just stick to `[contenteditable="true"]` for now, even though it doesn't represent what we're truly looking for. Here are some things we found:
  - Safari + Firefox: When `[contenteditable="plaintextonly"]`, the `beforeinput` event will still show `text/html` data in the `InputEvent.dataTransfer.types` even though such information is arguably irrelevant, and `InputEvent.getTargetRanges()` will return the correct information. Additionally, `InputEvent.data` will be `null`.
  - Chrome: When `[contenteditable="plaintextonly"]`, the `text/html` data will not be exposed by the `InputEvent`. In fact, `InputEvent.dataTransfer` will be `null`! And the developer will have to check `InputEvent.data` instead. This makes some sense. However, Chrome also excludes the `InputEvent.getTargetRanges()` data in this scenario, making it difficult (if not impossible) to reasonably re-implement the `input` event's behavior fully.
  - Due to these inconsistencies (especially when it comes to `dataTransfer` vs `data`), it's best to just stick to `[contenteditable="true"]` since doing so will result in consistent behavior across browsers, in addition to guaranteeing that we'll always have access to the correct Target Ranges.
  - It's currently unclear whether we should file a Chromium Bug for this right now since it isn't clear which browser has the "correct" behavior. Both implementations have some downsides to them.
- It seems that when you're inserting text into an empty element, the `StaticRange` returned from `beforeinput` points to the element itself instead of the empty `Text` node that the element holds (assuming element contains a `Text` node). When you're leveraging the `StaticRange`s returned from `InputEvent.getTargetRanges()`, you need to take this into account. If you can force circumstances that allow you to make valid assumptions, then you can work conveniently with those assumptions.
  - For example, if you can guarantee that the target element will always have a single `Text` node and nothing else, then you can just opearte directly on that `Text` node instead of referencing `StaticRange.startContainer`.
  - Otherwise, you'll need to bring about whatever circumstances that you require. For example, if you _need_ the target element to have a `Text` node, then you can check the element returned from `StaticRange.startContainer` for a single `Text` node child. If one exists, you can operate on it. If one doesn't exist, you can insert a new `Text` node into the element and then operate on that text node.
- It seems to be safe to remove `\r`s and `\n`s from an `InputEvent`'s data before interacting with the `StaticRange`s from `getTargetRanges()`. This is because newlines are represented by newly-created `HTMLElement`s, which themselves become `contenteditable` (because of the owning/wrapping `contenteditable` element) and have the ability to receive `beforeinput` events which bubble up to the owning element that listens for all `beforeinput` events. This paradigm makes it unnecessary for the `StaticRange`s to take newlines into account in their `offset`s, so characters like `\r` and `\n` don't influence the `offset`s at all. Therefore, it is perfectly safe (from what we can tell from our brief testing in Firefox) to delete all `\r`s and `\n`s from a string before interacting with the `StaticRange`s.

## Testing

- [Playwright's approach to its `ControlOrMeta` key](https://github.com/microsoft/playwright/blob/8e4627826a6bacdc97582e53ee34a1db4a9647e7/packages/playwright-core/src/server/input.ts#L153-L157) (search for `ControlOrMeta` or for `resolveSmartModifierString`) involves leveraging [`process.platform`](https://nodejs.org/api/process.html#processplatform).
- Apparently, MacOS doesn't allow tabbing to controls like `<button>`s by default. Because of this, if you run Playwright against a Safari (WebKit) browser on MacOS, all tests expecting `<button>`s (or other similar controls) to be focused via `Tab` navigation will fail. (Note: This is not an issue for all controls. For instance, `textbox`es work just fine.) This is why your Safari tests may work on a Linux Machine in CI, but not locally on your MacOS machine. The solution to this problem is to enable tabbing into controls on your local MacOS.
  - Enabling this in Safari > Settings > Advanced > "Press Tab to highlight each item on a webpage" **_will not_** work. It will work for your local Safari version, but **_not_** for your Playwright Tests.
  - Instead, visit System Settings > Keyboard > Keyboard Navigation. The subtext for this option says something like:
    > Use keyboard navigation to move focus between controls. Press the Tab key to move focus forward and Shift Tab to move focus backward.
    - Toggle "Keyboard Navigation" on by clicking its toggle switch. Now your Playwright test(s) should be passing.
  - See [Stack Overflow](https://stackoverflow.com/questions/67901731/cannot-focus-button-using-tab-key-navigation-on-safari/67901876#67901876) for additional details.
- In `@playwright/test@1.54.1`, the [`Locator.fill()`](https://playwright.dev/docs/api/class-locator#locator-fill) method does not work in Firefox when used on a `[contenteditable]` element whose text content and cursor location are modified by a `beforeinput` event. (See [microsoft/playwright#36715](https://github.com/microsoft/playwright/issues/36715) and [Playwright Issue Firefox Fill](https://github.com/ITenthusiasm/playwright-issue-firefox-fill).) In such a scenario, Playwright will duplicate the provided text when running against Firefox. This issue does not happen during manual testing, nor does it happen if Playwright is run against Chrome or Safari. (We discovered this bug on a MacOS machine. Not sure how other machines behave.) Moreover, this issue does not occur when using [`Locator.press()`](https://playwright.dev/docs/api/class-locator#locator-press) or [`Page.keyboard.press()`](https://playwright.dev/docs/api/class-keyboard#keyboard-press). It's not clear why the `Locator.fill()` bug exists; but for now, if it becomes a problem, you can circumvent the issue by sticking to Keyboard Pressing instead of Locator Filling. Doing so is just as reliable (if not more reliable), but it's slightly less convenient.
- Apparently, valid CSS identifiers [cannot start with an unescaped number](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/id). When working with unique [IDs](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/id) in JavaScript, this is basically never a concern because `document.getElementById()`, which accepts IDs starting with unescaped numbers (since they constitute valid IDs), is always preferred over `document.querySelector()` for performance reasons. However, this concern **_does_** matter in Playwright, since it tends to use `document.querySelector*()` for its `page.locator()` method. Note that although `document.querySelector("#123")` is invalid, `document.querySelector("[id='123']")` is perfectly acceptable (_notice the intentional use of quotation marks_), so the latter is **_ALWAYS_** to be preferred over the former _in Playwright Tests_.

## Custom Element Integration with JS Frameworks:

- React:
  - https://react.dev/blog/2024/04/25/react-19-upgrade-guide#the-jsx-namespace-in-typescript
  - https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api/#adding-non-standard-attributes
  - https://react.dev/reference/react-dom/components#custom-html-elements
- Svelte:
  - https://svelte.dev/docs/svelte/typescript#Enhancing-built-in-DOM-types
  - https://svelte.dev/docs/svelte/custom-elements
- Solid
  - https://docs.solidjs.com/reference/jsx-attributes/use#typescript-support
  - https://github.com/solidjs/solid/discussions/1123#discussioncomment-3163029
  - https://docs.solidjs.com/concepts/components/event-handlers
  - https://docs.solidjs.com/reference/jsx-attributes/on_
  - https://docs.solidjs.com/reference/jsx-attributes/on
- Vue:
  - https://vuejs.org/guide/extras/web-components#non-vue-web-components-and-typescript
- Preact:
  - https://preactjs.com/guide/v10/typescript/#extending-built-in-jsx-types
  - https://preactjs.com/guide/v10/web-components/
  - [Don't call `render` from inside a component file](https://github.com/preactjs/preact/issues/3393#issuecomment-1005019205)

## Node Workspaces / TypeScript Project References

- The ordering of your [package `exports`](https://nodejs.org/api/packages.html#exports) rules matters. Always be sure to place more specific export paths **_before_** less specific ones. For example, place `"./*.js": "./*.js"` and especially `".": "./index.js"` **_before_** `"./*": "./*.js"`.
- [**Building TS Projects Using Project References**](https://www.typescriptlang.org/docs/handbook/project-references.html): Typically, it should be sufficient for you to run `tsc --build` (or `tsc -b`) to build your "root" `tsconfig.json` file along with all of its dependencies (listed under `references`). However, if you're type-checking even a _single_ `*.vue` file, you have to use [`vue-tsc`](https://github.com/vuejs/language-tools), which seems to _require_ developers to pass all relevant `tsconfig`s to it during a TS Project References Build. For example, you'll have to run `vue-tsc --build . src` instead of `vue-tsc --build`. Somehow, Svelte files aren't picked up by `tsc` (unlike Vue files), and Svelte can lint its files separately through `svelte-check`. This is something Vue should look into.
- The downside of using Project References is that there is no "linting only mode". That is, you _must_ run `tsc --build` in order for all the types to be checked (and seen) correctly. And that means some files (specifically those which belong to `composite` TSConfigs) will emit `.d.ts` files even if you don't want them to. However, you can always clean these emitted files up easily with `tsc --build --clean` or with your own node script. Why bother with the headache? Here are just a few reasons:
  1. If you can structure your code rightly (without sacrificing sanity) with Node Workspaces and Project References, you can easily build your various projects without having to write or maintain your own build scripts.
  2. Node Workspaces and Project References, when used together, help you learn how well your [package `exports`](https://nodejs.org/api/packages.html#exports) work, how reliable your type definitions are, and how your _global type augmentations_ behave **_BEFORE_** you publish your NPM Package.
  3. With Project References, you can pass an empty array (`[]`) to `compilerOptions.types` for a _subset_ of your projects. In our case, it means that we can prevent the `src/**/*.js` files from accidentally picking up Node's `setTimeout()` function when we just want to use the browser's `setTimout` function. At the same time, we can still allow global Node.js types to exist in the rest of the project. **_Very_** helpful.
- Getting `@typescript-eslint` to work with project references requires the [`projectService`](https://typescript-eslint.io/blog/project-service/) boolean option to be set. We _think_ we've set it up correctly in this repo. We can fix it later if not, but at least lint seems to be behaving correctly over all.
- Somewhere along the way, using NPM Workspaces and TS Project References seemed to break `npm`'s ability to "see" the `*.d.ts` files during an `npm publish`. (Or perhaps something else broke this, such as the way we've written our scripts. However, after doing a little bit of testing, that seems much less likely.) It seems [other people](https://stackoverflow.com/questions/67523877/index-d-ts-file-not-published-to-npm) have run into problems like this before, and the simple solution is to use the [`files`](https://docs.npmjs.com/cli/v11/configuring-npm/package-json#files) configuration option in the relevant `package.json` file _instead of_ using a `.npmignore` file.
